TODO list:

# DONE WORK


4、参考其他内核，给不同架构的页表的bits设定一个统一的表示。(done)
5、根据修改过的架构统一页表flag表示，修改原先的代码。(done)
6、添加清理tlb的部分(紧急！！！因为试图反复把某些页面映射过去，所以必须刷新tlb，而不刷新就会出问题。实际上map函数较为工作良好)(done)
7、添加map函数的test和unmap的实现(done)
8、实现nexus(done)
9、实现spmalloc(done)
11、启动PIT时钟，并用于校准APIC时钟(Done)
12、阅读intel文档，完成x86下简单的中断的保存的处理（如有需要，可以参考Linux实现嵌套中断的情况），查找为何进入中断idt向量之后，没有硬件cli的问题并修复。(Done)
13、尝试实现x86下一个简单的时钟系统。最起码可以delay并且读取最新的时钟(Done)
14、根据mdelay的实现，完成APIC多核的启动。(Done)
16、学习了解aarch64的smp启动（Done）
17、x86 64既然已经运行起来了smp，需要进一步的启动其他核心（Done）
18、尝试更新makefile，我认为包括以下几个地方：是否能有个脚本，在运行期生成子文件夹下的makefile，因为看上去都相同。是否可以把.d文件生成到build下的对应文件夹下，而不是生成在当前文件夹。(Done)
20、学习Linux的mcs spinlock，设计并实现多核spinlock(Done)，并整合到现有的多核mm中去，以及多核输入输出中去（Done）。
21、了解 arm的generic timer（Done）并设计实现arm下的时钟以及时钟中断的处理。(Done)
23、需要了解aarch64的中断和Syscall处理这一部分，开启中断以及相应的处理。(Done)
24、我完成了aarch64的简单的时钟中断的实现，但是剩下几个问题，在系统的timer函数中，还有一个X86 64的平台相关的ifdef（Done），然后generic time这里还有一个因为头文件include的问题导致的vs code的显示问题影响观感(Done)，还有就是，不知道为什么还有一个aarch64 跑起来的一个unknown trap，应该是没注册导致的，不确定(Done)。这几个bug需要修复。另外，加上了aarch64的时钟之后，x86_64看上去并没有成功的定时了，以至于出现了超过1s启动起来，我怀疑存在额外的问题，如果不是，也需要修复这个问题。(Done,直接改到10s了，应该，大概，就是单纯的时间更长了)
29、已经有了相关dtb解析的代码，可以在启动的时候，动态解析aarch64下的dtb中的uart的位置，以让内核更通用化。(Done)我在这里使用的代码跟查找memory那里的主要逻辑基本相同，需要继续封装(Done)
32、检查在percpu初始化之前，使用到percpu参数的那些地方，这可能埋了雷。(DONE)

# TODO WORK

1、设置好IDT表，这需要设置好相应的gdt表中的段，type的设置，dpl，cpl，rpl在64位模式下的使用情况。
2、考虑8259A存在与不存在使用APIC的情况。
3、完善CPUID的部分，不要每次都要读取一遍了。
10、查看是否会修改一些页表项中的隔离域等问题
15、设计好给不同核心以及同一核心上的stack的页面以及权限，如果有需要，需要给maphandler添加更改页面权限的函数。
19、acpi的基本解析目前结束了（虽然只使用了很少一部分），并且相对独立，需要整理到modules中来实现模块化，当然，可以理解的是，部分跟内核强相关的函数，不得不实现在内核中，这部分需要额外一些函数调用。
22、在cpu id这部分，我们实际上需要考虑cpu本身的信息，以及cpu的拓扑情况。
25、考虑中断嵌套的情形，用于处理中断，同时考虑添加一个RT的flag，某些操作（比如时钟）其实不适合允许中断嵌套或者中断线程化
26、测试内存分配器的cacheline的碰撞概率。
27、算是上一条的子任务，因为测试内存分配器的cache碰撞概率，需要知道cpu核心的cache大小，而这点在smp上可能是不同的，因此，需要把cpu info改为percpu的，并且添加相应cache的内容。
28、根据上述的cacheline碰撞概率测试，优化malloc分配器的行为。
30、bitmap是一个重要的数据结构，但是Linux的实现中也包括了原子的（架构相关）和非原子的，需要实现相应的代码，但是注意common并不应该包含其他的数据结构。（请注意头文件包含）
31、使用memory_zone等传递进去的参数改写默认的ZONE_NORMAL参数，对于模块来说他的参数应当是在上层初始化等时候设定好的，而不是硬写进去的。
33、开启简单的进程相关调研和设计
34、设计如何让内核实现拆分，用户程序、内核的上层接口和rendezvos核心如何拆分到多个仓库并进行联合编译，同时，内核可以指定不同的接口仓库以适应不同的内核接口，以及可以测试一些用户程序（但不能侵入式的修改内核代码，以适应更多可能的内核仓库）