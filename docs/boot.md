# x86架构下
## 关于multiboot2
我试图shampoos中使用multiboot2协议来引导，但是，当我按照multiboot2的格式写了引导程序之后，发现事情并没有那么简单，现有的qemu版本并不能支持这个协议。
同时我发现multiboot1协议在qemu中无法直接支持x86_64的启动引导。
我找到了一个可能存在的RFC：
https://lore.kernel.org/qemu-devel/20240206135231.234184-1-jens.nyberg@gmail.com/
但是在我编写这份代码的时候（2024年3月），这个patch才在一个月之前才被提交到内核邮件列表
但是，对于X86_64文件的支持，仍然是必须的，否则我就必须想别的办法去完成引导 。

## PVH
直接加载x86_64的elf文件，可以在其中加入一个ELF note
https://stackoverflow.com/questions/64492509/how-can-i-create-a-pvh-kernel-that-will-be-run-by-qemu
原因在于
https://stefano-garzarella.github.io/posts/2019-08-23-qemu-linux-kernel-pvh/
可以直接支持x86_64镜像的协议必须这样子写
对于相关协议，可以看
https://xenbits.xen.org/docs/unstable/misc/pvh.html

对于x86_64上面的引导，我仍然使用multiboot1，因为他确实可以很好的引导32位的代码，当然我想这不是决定性的解决方案，决定性的问题在于，我应该使用bin文件而不是elf文件格式来作为加载的内核镜像。

## 生成bin文件并加载
直接使用elf文件无法加载
因此可以使用objcopy生成bin文件再进行加载。
在这种情况下，就可以使用multiboot1协议进行加载了
OK，问题解决。
对于multiboot1协议，可以参考以下链接
https://www.gnu.org/software/grub/manual/multiboot/multiboot.html

# 从boot到32位模式代码
在32位模式下的一个选择在于，是否使用PAE进行地址扩展，尽管目前绝大多数的处理器都支持，但是仍然希望能够进行适配。
首先是通过CPUID来查看是否支持这个扩展
然后再分情况考虑是否适配。
但是既然都用了CPUID指令了，还是需要在这里做一套完整的代码用于记录CPUID所获得的众多info


# 从boot到64位模式
考虑实际代码架构，由于这几个架构都会存在从物理地址到虚拟地址的转换，这个步骤会先恒等映射kernel地址，然后再进行跳转，而aarch64和riscv64，在进入这一步骤之前，都是没有更多和x86_64统一的步骤的，因此，在进入64位模式这段代码，需要在跳转到公共的arch之前就启用。

关于具体启动的顺序，可以参考intel手册的volumn 3A 4-3这里面有一张状态转换图
为了能够到达IA-32e paging
需要先开启PAE和LME，然后再开启PG，这是固定的要求

一个很不幸的事情是，必须先查看cpuid是否支持1GB的大分页，然而我的平台上显示他并不支持（事实上，我们也没必要总是需要他可以支持，只用2m的分页就够了对吧）
所以只能用2m的分页，但是，2m分页可能无法容纳整个内核的大小，因此，需要根据内核的上下限，去设计到底有多少内核空间被映射进来。并修改页表。

随后需要使用lgdt来跳转到64位代码段执行，就我查的资料和个人看法，这个lgdt仅仅是让我们代码从原先的32位改到64位的作用。

但是在这时候，仍然在恒等映射区域运行，需要通过一个ljmp跳转到高地址区域（也就是链接脚本中指明的实际代码链接的地址）。
在这之后为了安全性，需要取消恒等映射区域。

到了这一步，内核总算正确运行在一个正确的虚拟地址空间了（撒花~）




# riscv64

# arm64
我对arm64的一大堆寄存器都不熟悉，因此，我会尽可能详细的在此记录

当我试图在aarch64下直接qemu启动的时候，他会自动的运行到0x40080000
但是这是qemu的布局，和x86这种有巨大历史包袱的东西不同（我没听说过x86在1M这个分界上的处理会有什么不同的做法，毕竟都是需要进入保护模式的），arm可能根据板子的不同加载到不同的地址。

还有就是跟启动协议相关的部分，我找到了这个。
https://mjmwired.net/kernel/Documentation/zh_CN/arm64/booting.txt
虽然我们并不是一个linux，但是出于通用的约定（并且他并不复杂）我决定按照这个方式去实现我的内核。
x0寄存器会存放dtb，所以保存dtb的值是一件非常必要的事情。
除此之外尽管现在x1,x2,x3是0，但是，未来有可能会被用到，所以这些寄存器也是需要保存的。

对于启动时候的状态，额在这里他虽然说推荐是el2，但是实际上，也有可能是el1，我不知道是否有可能是el3（因为我参考arceos的时候，这是考虑了el3的情况）。
因此需要做的事情是，查找当前的el等级。
对于如果当前是el1，那么不用管，否则需要分别考虑处于el3和el2的情况。

## el3
在arceos中的el3的代码中，他设置了scr的NS，HCE，RW，位
设置了SPSR_EL3的M,D,A,I,F位
然后设置了ELR_EL3
## el2

arceos中，设置了EL1的timer的trap，设置了HCR_EL2寄存器，然后也设置了SPSR寄存器的M,D,A,I,F位
随后也设置了ELR_EL2

在这里，arceos还试图设置了spsel寄存器，试图选择堆栈，但是，我认为在直接汇编写的情况下没有必要。因为他不需要堆栈

## linux的实现
他在el2阶段还设置了其他的寄存器
包括el2阶段的中断向量，但是总而言之，设置好spsr和ELR两个寄存器，其实这里面可以说再经过eret就到了el1了。

然后对页表做一些设置，反正就硬映射呗。
（这部分需要了解一下AArch64的页表项的实现）

然后进入init mmu
写tcr，写ttbr0和ttbr1
然后写入SCTLR寄存器的某些位，设置好mmu和cache

中间千万注意需要刷新barrier和刷tlb
大概需要做的事情就是这些了。

SPSR寄存器

SCTLR寄存器

SPSEL寄存器
可以选择使用的SP寄存器。
只有最低位是有效的，如果是0表示选择当前的sp为el0的sp。

## 其他注意事项

关于对齐
在x86中，.align n指令后面跟的是绝对的对齐的数据，但是在arm中align是2^n。