# IPC 设计

IPC包括同步IPC和异步IPC两套机制，由于内核中的设计是除了最核心的机制其他都成为一个thread。

因此，IPC过程在本内核中，是一个非常重要的机制，

对于同步IPC最重要的是，他实际上，是个函数调用，也就是说，最好当然是直接切换到对应的进程。

当然，这里面涉及到多核的问题，所以，也没那么简单。

使用多个client和一个server的情况，来描述这个更具象一些。想像一下，有一个设备，以及有多个核心，这个设备开了一个线程，独占这个设备，每个核心的其他任务，需要跟这个设备通信，都需要发送消息给这个线程。假定每个核心都试图跟他通信。

首先一个问题是，哪个核心执行这个线程？一种方案是，设定该线程的affinity。只有该affinity的核心可以调用，这样对于cache肯定是最好的。但是，如果该核心一直不试图发送消息，而是运行更高优先级的任务，那么其他核心如果还等着（哪怕是异步，也需要在某些时刻等待并poll），那这个性能就很让人无语。

那这肯定不太靠谱嘛。所以这个线程不能这样设置Affinity。相反的需要设计为第一个试图发消息的核心就应该直接切换过去并执行。

但是其他的核心上的进程，既可以以同步的方式切换到其他进程，或者可以自旋，也可以以异步的方式，进一步地运行下去。那我直接实现一个mutex？那，应该也不是那么简单，首先，消息队列的处理应该是尽量无锁并高性能的。但是或许可以让他们在试图执行的时候试图获取锁，表明自己的核心试图切换到该进程处理消息，这样来实现消息队列处理和切换到该进程处理的分离（那后者确实是个mutex，试图获取锁并进入该进程，否则就直接切进程了）。

## 为什么需要在同一个地址空间的模块间调用转为IPC

关键点在于，减少裸的临界区的使用，也就是说，如果原本有两个内核线程，需要使用一个临界区，然后共享某个资源，这时候是需要上锁的。但是，如果使用IPC的方案，那么，临界区的代码，可以封装为一个新的线程，而两个线程对临界区的使用，就转变为两个线程向这个线程发IPC,在消息队列使用锁或者无锁队列，使用集中且核心的锁机制，而内核编写者只需要关心无锁情况下的代码，，可以充分地降低使用锁带来的并发问题。

## 通信核心进程

如果采用基于端口或者其他总之类似的东西来通信的话，总有那么一个进程需要告诉其他进程，想要通信的进程占用了哪个端口

因此，如果某个进程不知道跟谁通信，他就必须发消息区询问这个通信核心进程，然后再进一步的去发消息给目标进程的端口。当然，每次发送的时候依然要检查该端口是否被撤销，除此之外，还有个，端口一般都是会考虑复用的，如果进程A先申请了端口C，然后进程A撤销了该端口的使用，随后进程B，又申请了端口C，那不能直接对着这个端口去发消息，因为这会发送给B，所以，一种方案是使用序列号或者magic等操作，进行验证是否仍然是进程A

因此，它也能被视作通信的核心进程，（如果需要权限管理的话，这个可以更进一步的延伸）

但是，这在调度上会引入一些额外的问题，目前的情况是，每个core都有一个调度队列，但是，这个通信核心进程，或者类似的，系统中应当只有单个实例的进程，需要怎么个调度法呢？？？
它总不能来回的在多个核心的队列之中迁移吧。

我的一个思路是这样的，这些系统服务，虽然作为一个内核线程，但是并不直接放在调度器当中调度（因为实质上也确实是一些静态服务）。在某个核心上的进程抢到该线程的执行权限之后，会通过switch to切换过去，但是，调度器的current thread 仍然指向原来的进程，然后在结束之后，反而不需要寻找返回的给谁，因为current thread里面记录了原先的thread。

两种方案，一个直接切换到current thread指向的原进程，另一个是直接schedule切换就行。

前者的问题是，需要额外找个东西记录一下系统服务的线程。后者的问题是，需要同步改schedule的代码，因为，目前运行的是系统服务的线程，而schedule是从current thread切换过去的。这会导致，switch to会覆盖掉前一个switch to保存的ctx，将当前的系统服务进程的一些上下文进行保存，这显然不是个好主意。

还有一个问题在于，这些系统服务是否应该是无执行状态的（当然不是完全无状态，因为他还是会记录一些东西嘛。这里指的是，在每次执行结束之后，没必要保存上下文和堆栈的状态，也就是执行状态）。如果他是不会阻塞的，我觉得没问题，每次都是从栈底和入口开始执行，并切换走。下次还是从这里开始执行。但是在某些情况下，可能会阻塞住（比如等待磁盘读写完成），这时候会给调度带来更麻烦的情况。原先第一个抢到锁的就可以去执行，但是现在还要判断这个系统服务进程是否是可以运行的，如果不是就切换走（不过，我觉得这种情况没必要讨论，因为实质上有一个进程获取了这把锁）。从这个角度来说，看似需要保存上下文，但是这个保存上下文的操作，是在该系统服务线程执行过程中出现的操作。在该系统服务线程执行开始和结束的时候，他的执行状态确实还是没必要保留的。

那从这个角度来说，在第一个switch to到系统服务线程的时候，只有current thread的上下文需要保存，而系统服务线程上下文，完全可以是从头构造的一个，另一方面，在切换回去的时候，也可以直接在栈上构造一个没有任何作用的上下文。（没必要再拆解switch to函数）。不过，以x86为例，switch to的上下文，其实是函数调用相关的参数（callee保存的嘛）。这就实质上变成了函数调用。也就是所谓的通信IPC变成了函数调用。

这里依然存在一个问题，那就是返回值。进入的时候，是手动构造系统服务线程的上下文充当function call的参数，返回的时候需要把这个系统服务线程的返回值再存放到对应的current thread的上下文上。

那么其他的IPC呢？？？其他的IPC本身是挂了个消息到这个线程上的，并不是通过这种类似于function call的方式。意味着如果需要返回参数，还需要再发个消息。而这需要在其他被阻塞的ipc恢复执行的时候，查看IPC并塞到对应的寄存器里面，然后给出一个无感知的结果？这就更为复杂了。

（当然我知道这种无状态的系统服务是得进一步的抽象）

另一个问题是，同步和异步的接口设计，上述的实现是均为同步的接口实现的。也就是说，必定存在一个core上的线程试图直接执行它，但是，如果考虑进异步，问题会更为复杂。

如果是异步的情况下，可能所有的core都不要求立即调用这个thread，而是要求调度器在有空的时候调用即可，可能会实现一个poll或者wait等待结果。这时候，注意前文的描述，这些服务线程并不直接放在每个core的调度器的队列中，那么，什么时候调用，如何调用仍然成为问题。

对于何时调用的问题，一种是按照时间或者某些调度点的时候，进入该调度点，或者计数达到某个值，就可以了。另一种，则是根据消息来，但是同样还是需要设置调度点，该点去检查是否存在ipc端口（也就是对应的线程）的消息数量足够多。如果够多就直接调度过去。当然，我觉得最值得一提的方案应该是，这里提到的通信核心进程。每个core上都有这样一个通信核心进程，他会检查发给他的各类消息（也就是前面提到的查询消息），同时在处理完了消息之后，就查询所有的端口（理应实现为一个bitmap），是否存在某个服务进程需要处理。之后按照正常的上面所述的消息机制，试图抢到该进程，并执行。我认为这是有一定的优点的。所有的服务进程实质上在某个核心上的执行时间都是根据current thread的时间片来的。

### 堆的分离

这是参考redleaf的，感谢yfblock提出的这个问题。目前我们没有考虑，因为，现有的设计已经足够复杂。

## 消息队列和端口的分离，一个进程占用多个端口

我最开始思考的是，消息队列（以Linux的信号为例，每个实时信号都需要按照顺序排列）因此，需要很多个消息队列，也意味着需要很多个通信端口。但是后来我意识到，这里存在一个消息队列和端口的分离，否则模型的复杂化将是非常致命的。

即，端口只用于表示目标的进程（或者线程），进程和线程确实是两个实体。而不同类型的消息进入了端口之后进行分发，则是另一个事情。当然分发之后才能处理。

不过，这并不意味着，一个进程只能有一个端口用于接受消息。他可能存在多个端口用于接受消息，例如，假设我把端口分为两类，实时消息的端口和非实时消息端口，带优先级或者高优先级的端口，和不带优先级或者低优先级的端口，也就是说，如果端口会有不同的属性，而这意味着不同的消息处理方式，他也可能一个进程包含多个端口。


## 回信

一个简单的道理是，如果来信里面直接包含了端口号，那就简单很多了。不过，仍然需要检查，端口是否存在，同样的由于之前的端口复用问题，他回信也应该检验序列号或者类似的东西。

## 消息队列的实现

消息队列的实现本身都最好实现为无锁的，不过正如前面所说，队头可能需要特殊处理。

另一个是RCU机制。这都是常用的消息队列的实现。

之所以提到这个机制，实际上来源于这样一个问题，有那么一个队列，源源不断的来消息，然后while循环源源不断的处理，并不加以结束，这会导致饥饿问题。

所以，这个系统服务进程作为一个读者，完全可以依照RCU机制，只能看到他读取的时候的副本。（但是吧，RCU适合于读多写少的机制，总不能让我弄个MVCC）

## 实现
### 第一步
首先，我们先不管什么奇奇怪怪的东西。实现最简单的框架。

每个进程具有一个消息队列，然后测试进程可以通过通信核心进程，发送得到某个进程所属port信息的消息，并且接收到回复，即可，当然也有注册把自己注册到某个进程上的操作。

同时，第一步，我们实现整个队列一个锁。

### 第二步
改成一个更为高效的锁结构。其他到也不用管

### 第三步
再进一步的实现同步的端口的快速直接切换机制。（实际上到了这一步骤，没有这种切换机制也是可以用的了），更重要的是异步的消息传递机制的效能。这样也可能未必是最优秀的

### 多核心的内存动态分配器的问题

显然，ipc会导致队列中，存在多个核心分配器分配的小块对象。所以，读取其他核心扔过来的消息，就会释放，意味着对多核心分配器的考验。

这需要进一步地改写其分配和释放的逻辑。尤其需要注意的是，不能简单的锁定自己核心之后，再锁定其他核心，这必定导致死锁。

另外，目前的nexus页分配器甚至没有考虑这一层，它分配一页，就是真的分配一页出去了，没有什么机制用于记录，这个页面到底是从哪个nexus分配的。如果要知道这一点，一个办法是暴力搜一遍，不过，肯定没法这样啊，另一个办法是，直接使用tagged ptr，但是由于其和sp malloc是混合的（即使用大量的内存的时候，就会去调用nexus的get free page接口，所以几乎所有alloc的指针，恐怕都需要进行一遍整理，所有这些方式申请的直接指针访问的地方，都得改，且这些指针需要存储，而spmalloc的看alloc id的也没必要再去判断了，我认为是个很优秀的方案） ，需要进一步地加以修改。

### 消息背压机制
虽然我也不是很懂，但是，我确实理解，在一个系统中消息发得过快是什么个问题。