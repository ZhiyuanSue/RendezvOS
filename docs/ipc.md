# IPC 设计

IPC包括同步IPC和异步IPC两套机制，由于内核中的设计是除了最核心的机制其他都成为一个thread。

因此，IPC过程在本内核中，是一个非常重要的机制，

对于同步IPC最重要的是，他实际上，是个函数调用，也就是说，最好当然是直接切换到对应的进程。

当然，这里面涉及到多核的问题，所以，也没那么简单。

使用多个client和一个server的情况，来描述这个更具象一些。想像一下，有一个设备，以及有多个核心，这个设备开了一个线程，独占这个设备，每个核心的其他任务，需要跟这个设备通信，都需要发送消息给这个线程。假定每个核心都试图跟他通信。

首先一个问题是，哪个核心执行这个线程？一种方案是，设定该线程的affinity。只有该affinity的核心可以调用，这样对于cache肯定是最好的。但是，如果该核心一直不试图发送消息，而是运行更高优先级的任务，那么其他核心如果还等着（哪怕是异步，也需要在某些时刻等待并poll），那这个性能就很让人无语。

那这肯定不太靠谱嘛。所以这个线程不能这样设置Affinity。相反的需要设计为第一个试图发消息的核心就应该直接切换过去并执行。

但是其他的核心上的进程，既可以以同步的方式切换到其他进程，或者可以自旋，也可以以异步的方式，进一步地运行下去。那我直接实现一个mutex？那，应该也不是那么简单，首先，消息队列的处理应该是尽量无锁并高性能的。但是或许可以让他们在试图执行的时候试图获取锁，表明自己的核心试图切换到该进程处理消息，这样来实现消息队列处理和切换到该进程处理的分离（那后者确实是个mutex，试图获取锁并进入该进程，否则就直接切进程了）。

## 通信核心进程

如果采用基于端口或者其他总之类似的东西来通信的话，总有那么一个进程需要告诉其他进程，想要通信的进程占用了哪个端口

因此，如果某个进程不知道跟谁通信，他就必须发消息区询问这个通信核心进程，然后再进一步的去发消息给目标进程的端口。当然，每次发送的时候依然要检查该端口是否被撤销，除此之外，还有个，端口一般都是会考虑复用的，如果进程A先申请了端口C，然后进程A撤销了该端口的使用，随后进程B，又申请了端口C，那不能直接对着这个端口去发消息，因为这会发送给B，所以，一种方案是使用序列号或者magic等操作，进行验证是否仍然是进程A

因此，它也能被视作通信的核心进程，（如果需要权限管理的话，这个可以更进一步的延伸）

## 消息队列和端口的分离，一个进程占用多个端口

我最开始思考的是，消息队列（以Linux的信号为例，每个实时信号都需要按照顺序排列）因此，需要很多个消息队列，也意味着需要很多个通信端口。但是后来我意识到，这里存在一个消息队列和端口的分离，否则模型的复杂化将是非常致命的。

即，端口只用于表示目标的进程（或者线程），进程和线程确实是两个实体。而不同类型的消息进入了端口之后进行分发，则是另一个事情。当然分发之后才能处理。

不过，这并不意味着，一个进程只能有一个端口用于接受消息。他可能存在多个端口用于接受消息，例如，假设我把端口分为两类，实时消息的端口和非实时消息端口，带优先级或者高优先级的端口，和不带优先级或者低优先级的端口，也就是说，如果端口会有不同的属性，而这意味着不同的消息处理方式，他也可能一个进程包含多个端口。


## 回信

一个简单的道理是，如果来信里面直接包含了端口号，那就简单很多了。不过，仍然需要检查，端口是否存在，同样的由于之前的端口复用问题，他回信也应该检验序列号或者类似的东西。