# pmm
首先说pmm模块的管理，pmm管理说到底就是管理页框
这部分，首先需要从multiboot获取所有可用物理内存的位置，并且减去内核占用调的部分。

随后我打算分成多个块，使用一个链表串联起来这些块（由于本身存在对齐的问题，并且linux也是分块进行内存分配的）

另外，需要使用buddy算法来分配物理页框，管理具体某一块的内容。

# buddy实现
首先参考Linux的实现中，他将内存划分为几个部分，称为zone
每个部分有个水位线
然后每个部分在这里面buddy会分桶，每个桶是2的倍数，针对不同的桶，去做一个链表。
在这里的设计，我们直接简单粗暴的对每个桶使用一个大的page_frame数组，分别表示每个桶里面的所有page。
事实上，静态开销相比之下更大一些。但是因为是数组，不需要动态分配，可以使用，也有其优势。

对于alloc
最开始应该是只有最高阶的桶会存在链表，如果要分配1个page，那么会从下向上查找，找到链表头的一个page_frame，先分成两部分，对应的page_frame结构是非常好查找的。把空的那块插入链表，不空的那块继续分配。

分配完了之后，如果这个页面已经有被分配了的，需要置位have alloc。

如果一整个大页面都分配了，需要递归的置位。

对于free，其实应该设计两个函数，第一个是free单个page，第二个是free多个page

对于单个page，首先检查是否分配出去了，如果没分配出去，那滚蛋，错误的free

然后释放，挂链表，如果兄弟也释放了，那么摘下兄弟，并把父亲给挂上。

对于多个page，他未必是按照order的内容去分配的，但是必须是连续的。
举个简单的例子

两层

 [0,1]   [2,3]   [4,5]
[0] [1] [2] [3] [4] [5]

全都是满的
现在要释放1，2，3，4，四个页面。
这里面，从1开始，1最后一位是1，所以他只能释放1个页面
然后现在最低变为2，2小于等于4，所以他最多只能释放2个页面，所以需要把 [2,3] 和 [2] [3] 都释放掉。
然后是4，b100，所以最多可以释放4个页面，但是，因为4+4> 4，所以只能到最终端，就是4,4的区间释放掉4，只有一个页面。
如果有多层的话，2向上溯只能上溯一层，但是4可以向上溯2层，如果判断出来需要释放4,8，那还需要继续上溯。
直到顶层页面。

相比于Linux的bitmap的异或，这未必是最优的，但是是可行的，而且实现难度更低一些。

在整个buddy pmm结构体中，使用多个bucket数组表示所有的内存之后

考虑zone，每个zone当中，主要使用两个指针数组来表示，一个指针数组用于表示在不同的order中，这个zone所指向的第一个page frame，在这个指针之前的page frame则是属于前一个zone，在这个frame地址之后的所有frame直到下一个zone的第一个frame，包括其中的可用的不可用的frame。

另一个指针数组则是用于描述可用的链表。这些frame则不是连续的，而是使用链表来连接的，也就是上面说的那个buddy的数组了。

# pmm内存的layout(x86_64)

high address
	-- - -- - -- - -- -
	buddy static part
	-- - -- - -- - -- - _end ROUND_UP 4K
	empty
	-- - -- - -- - -- -	_end
	kernel
	-- - -- - -- - -- - 0x100000
	bios part	:we cannot use
	-- - -- - -- - -- - 0x0
low address

# 这种静态buddy算法能够支持的物理空间
在这里，我们允许每个bucket的位置都可以分离而不是所有的bucket都必须连续的进行分配
除此之外，原先我的设计，将内核放置在最后1G的空间中。
但是考虑到极大的内存分配过程。这点空间是不够的，
TODO：因为这个分配数量可能超过1G的空间，所以如果有需要，需要进一步的更改L1_table中的值，从而在分配buddy空间的时候，需要考虑这一点。

此时，对于能够支持的物理空间的限制，仅仅只有在page_frame中的next和prev的位数的限制，我这边设置28位是因为在qemu的x86_64中使用了40位的物理内存空间（大概1T）

因此为了尽可能的通用，在aarch64的设计中，我也将tcr_el1的ips位设为最大40，防止出事情。

# shared memory 的处理。
对于每个page frame，还设置了一个字段表示shared memory的count数量，我认为6位表示count==64是完全足够的
不过，现在并没有加上这部分的处理逻辑，因此，这部分留作TODO


# zone的avaliable list的问题

在原有的设计下，他仍然可以正常工作，但是在新的设计下，所有的index都被有需要的时候用于表示物理内存了，所以，因此，我只能选择不使用头结点的方式

在这种方式下，在插入的时候需要判断这个指针是否为空，如果为空直接赋值avaliable_zone_head[index]，否则则调用frame list add 系列函数

同时，在删除的时候，需要判断是否只剩下这一个节点了，如果是，则将avaliable_zone_head[index]置为null，否则则正常调用frame list del

不仅仅如此，我在实践过程中发现，还需要在del head的时候更新链表的头节点指针，以及在add head的时候也需要更新（注意更新头节点指针和做删除以及add的顺序）