# 关于本文档
本文档主要是记录在发生int和trap的时候，硬件的处理行为

# x86_64
## volume 1 chapter 6
首先是栈，一个栈是用SS:ESP来描述的，push会地址向下并写入，pop会地址增加并弹出。
当前栈是由ss段描述的
EBP则用于描述栈帧的返回地址

栈帧的size，在64位模式下，都是固定的8Bytes，所以无需考虑奇奇怪怪的事情
栈中，使用EBP保存弹出的地址，而把过程的返回地址压入栈
RET指令会弹出返回地址到EIP上

在64位下，ss段的DPL让他自动修改为等于CPL
LDS ，POP ES等指令变得无效

### 在32位模式下的near call和ret
会压入参数，这时候esp是指向最后一个参数，再放上返回地址，这时候参数指向最后一个参数之下的返回地址
然后返回的时候，esp现在指向返回地址，先弹出返回地址到eip上，再弹出n个参数

### 在32位模式下的far call和ret
则不仅仅是EIP，先压入cs，再压入eip
其他一样

### 32位模式下跨特权级的call
只能通过一个gate，也就是比如IDT表里面指定的东西
然后需要切换栈，这个栈在每个特权级都有存在。并且在切换的时候自动保存。
比如当前是ring 3，那么ring 2，1，0的statks保存在TSS中（我查到的资料是说，这是TSS存在的唯一的理由）

而一个跨特权级的调用，在栈上的表现是（见figure 6.4）
会在原本的栈上，压入参数，在新的栈上压入SS:ESP,参数(参数是复制过去的，在call gate里面指定了复制多少参数过去),CS:EIP
然后再使用新的CS:EIP取代原有的

### 64位模式下的branch扩展

### sysenter和sysexit在64位下的扩展成了syscall和sysret
见chapter 4 volumn 2B（我还真有这本实体书，我翻书去）
这里总共只有syscall，sysenter，sysexit，sysret
#### syscall
保存syscall指令的下一条指令到RCX，从IA32_LSTAR载入到RIP
SYSRET则将RCX复制到RIP
syscall将RFLAGS的低32保存到R11，随后将IA32_FMASK(MSR C000 0084)载入到RFLAGS
除了RF之外的其他RFLAGS不会自动清除掉，在sysret的时候会从R11保存回去

syscall的CS的目标必须是ring 0
sysret的cs目标必须是ring 3

看具体操作
条件：CS.L == 1 && IA32_EFER.LMA == 1 && IA32_EFER.SCE ==1
RIP的操作如上描述
RFLAGS操作如上（应该是EFLAGS）
CPL = 0
用IA32_STAR_MSR[47:32]指定的CS段（段描述符见书）
用 IA32_STAR_MSR[47:32]+8指定的SS段（段描述符见书）

#### sysenter
包括三个寄存器
IA32_SYSENTER_CS:0x174
IA32_SYSENTER_ESP:0x175
IA32_SYSENTER_EIP:0x176

（32位模式下）
CS是32位的，但是低16位用于指定CS段描述符，同样用于计算SS段（CS段的下一个）
EIP也是32位的。ESP也是

他并不保存调用者的信息（应该也是因此比较快吧）
需要保证CPUID SEP位，以及包括family和model和stepping
（以下不再描述32位情况下的sysenter的实现情况）

（64位模式下）
EIP和ESP两个MSR都是保存了64位的地址（canonical模式）而CS则包含一个NULL选择子

#### sysexit
和sysenter是一对
IA32_SYSENTER_CS仍然用来做段寻址
EDX相当于EIP
ECX相当于ESP
多余也不说了（感觉没啥意义，在RendezvOS下应该是纯64位模式，不用这个）

#### sysret
sysret按照syscall的相反步骤，从rcx复制到rip
对于段选择子，CS被选择为 IA32_STAR[63:48]+16而SS则被选择为+8（和syscall并不相同，他是先ss再cs）
这里返回的时候还需要考虑compatibility mode（应该不用管）

### 中断和异常（应该也是32位）
这里的简单介绍，值得注意的两点（其他对我而言都是常识）
1、并不是所有的额中断都是对应于一个IDT entry，比如SMI
2、当查看到中断时或者异常的时候，处理器可以选择其中之一做：1、执行一个handler procedure（应该是一段过程） 2、执行一个handler task

这里说，类似于call gate
int和trap有点不同的是，int会清理掉if位，然后禁止中断嵌套（直到内核主动打开返回或者允许嵌套）

如果目标代码段和源代码段处于同一个特权级，那么会沿用原有的stack，否则会切换stack
如果没有发生stack切换（也就是同一个特权级）
会从前到后，push eflags，cs，eip
再push error code

而如果一个stack 切换发生了（也就是切换了特权级）
会从前到后，先保存需要后面push的内容，并按照TSS中给定的情况切换新的栈，然后在新的栈中push ss esp（压入原有的堆栈） ，eflags，cs，eip
再压入error code

文档中也描述了前面说的可以执行一个handler task，通过调用一个task gate desc（但是他在64位模式下我不确定是否可行）

### 64位模式下的中断和异常
所有的handlers都是64位的

中断栈都是64bit对齐的

**无论是否切换栈，都会压入SS：RSP，**（32位模式下只有CPL发生变化才切换）

IRET行为相应的发生变化

新的中断栈切换行为（但是没说是啥，估计得看volumn 3？）

栈帧的对齐也不同

（总而言之，我们继续来看volumn 3中对这个尤其是栈的介绍吧，感觉volumn 1介绍还是太少了）

## volume 3 chapter 6

外部中断通过处理器上的引脚或通过本地APIC接收。奔腾4、英特尔至强、P6系列和奔腾处理器上的主要中断引脚是LINT[1:0]引脚，连接到本地APIC（见第10章“高级可编程中断控制器（APIC）”）。启用本地APIC时，LINT[1:0]引脚可以通过APIC的本地向量表（LVT）进行编程，以与处理器的任何异常或中断向量相关联。

当本地APIC被全局/硬件禁用时，这些引脚分别配置为INTR和NMI引脚,INTR引脚向处理器发出了外部中断的信号,处理器从系统总线读取外部中断控制器（如8259A）提供的中断向量编号（见第6.2节“异常和中断向量”）。NMI引脚表示非可屏蔽中断（NMI），该中断被分配给中断向量2。

请注意，处理器上的其他几个引脚可能会导致处理器中断。然而，这些中断不是由本章中描述的中断和异常机制处理的。这些引脚包括RESET#、FLUSH#、STPCLK#、SMI#、R/S#和INIT#引脚。它们是否包含在特定处理器上取决于实现。针脚函数在单个处理器的数据簿中进行了描述。第34章“系统管理模式”中描述了SMI#引脚。

### 可屏蔽中断
任何通过INTR引脚或通过本地APIC传递到处理器的外部中断都称为可屏蔽硬件中断。可以通过INTR引脚传递的可屏蔽硬件中断包括从0到255的所有IA-32架构定义的中断向量；可以通过本地APIC传递的中断向量包括中断向量16到255。

EFLAGS寄存器中的IF标志允许所有可屏蔽硬件中断被屏蔽为组（见第6.8.1节“屏蔽可屏蔽硬件中断”）。请注意，当中断0到15通过本地APIC传递时，APIC表示接收了非法向量。

INT n指令允许通过提供中断向量号作为操作数从软件内生成中断。例如，INT 35指令强制对中断处理程序进行隐式调用，以进行中断35。

从0到255的任何中断向量都可以用作本指令中的参数。然而，如果使用处理器的预定义NMI矢量，处理器的响应将与以正常方式生成的NMI中断不同。如果此指令中使用向量编号2（NMI向量），则会调用NMI中断处理程序，但处理器的NMI处理硬件不会被激活。

在软件中使用INT n指令生成的中断不能被EFLAGS寄存器中的IF标志屏蔽。

1/处理器检测到的程序错误异常。
2/软件生成的异常。
3/机器检查异常。

#### 1/处理器检查到的程序错误异常
包括几种类型
fault
traps
aborts
 - 故障——故障是一种通常可以更正的异常，一旦更正，程序就可以在不失去连续性的情况下重新启动。当报告故障时，处理器会将机器状态恢复到开始执行故障指令之前的状态。故障处理程序的返回地址（CS和EIP寄存器的保存内容）指向故障指令，而不是故障指令之后的指令。

 - 陷阱——陷阱是在执行陷阱指令后立即报告的异常。陷阱允许在不失去程序连续性的情况下继续执行程序或任务。陷阱处理程序的返回地址指向在陷阱指令后要执行的指令。

 - 中止——中止是一个异常，它并不总是报告导致异常的指令的确切位置，并且不允许重新启动导致异常的程序或任务。中止用于报告严重错误，如硬件错误和系统表中不一致或非法的值。

#### 2/软件生成的异常
INTO、INT 3和BOUND指令允许在软件中生成异常。这些指令允许在指令流中的点上检查异常条件。例如，INT 3导致生成断点异常。

INT n指令可用于模拟软件中的异常；但有一个限制。如果INT n为架构定义的异常之一提供向量，处理器将向正确的向量生成中断（以访问异常处理程序），但不会在堆栈上推送错误代码。即使相关的硬件生成的异常通常会产生错误代码，也是如此。异常处理程序在处理异常时仍将尝试从堆栈中弹出错误代码。由于没有推送错误代码，处理程序将弹出并丢弃EIP（代替丢失的错误代码）。这将导致返回错误。

#### 3/机器检查异常
主要是中断号18


为了允许在处理异常或中断后重新启动程序或任务，所有异常（中止除外）都保证在指令边界上报告异常。所有中断都保证在指令边界上进行。

对于故障类异常，返回指令指针（处理器生成异常时保存）指向故障指令。因此，当程序或任务在故障处理后重新启动时，故障指令会重新启动（重新执行）。重新启动故障指令通常用于处理对操作数的访问被阻止时产生的异常。这种类型的故障最常见的例子是页面故障异常（#PF），当程序或任务引用位于不在内存中的页面上的操作数时，就会发生该异常。当出现页面故障异常时，异常处理程序可以将页面加载到内存中，并通过重新启动故障指令恢复程序或任务的执行。为了确保重新启动与当前执行的程序或任务进行父级处理，处理器保存必要的寄存器和堆栈指针，以允许在执行故障指令之前重新启动到状态。

对于陷阱类异常，返回指令指针指向陷阱指令之后的指令。如果在传输执行的指令期间检测到陷阱，返回指令指针会反映传输。例如，如果在执行JMP指令时检测到陷阱，返回指令指针指向JMP指令的目的地，而不是JMP指令之后的下一个地址。所有陷阱异常都允许在不损失连续性的情况下重新启动程序或任务。例如，溢出异常是一个陷阱异常。在这里，返回指令指针指向测试EFLAGS.OF（overflow溢出）标志的INTO指令之后的指令。此异常的陷阱处理程序解决了溢出条件。从陷阱处理程序返回后，程序或任务执行在INTO指令后继续执行指令。

中止类异常不支持可靠地重新启动程序或任务。中止处理程序旨在收集有关中止异常发生时处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。

中断严格支持重新启动中断的程序和任务，而不会失去连续性。为中断保存的返回指令指针指向处理器中断的指令边界处要执行的下一个指令。如果刚刚执行的指令有一个重复前缀，则在当前迭代结束时进行中断，并设置了用于执行下一个迭代的寄存器。

### NMI 不可屏蔽中断
NMI 可能产生于两种情况
 - 外设通过NMI引脚
 - 处理器得到一个NMI的APIC的bus的信号
这些NMI的信号，不应该被IF所屏蔽
#### 多重NMI
会在IRET之前unblock下一个NMI
甚至于，如果IRET指向了一个错误，也一样会阻止

### 启用和禁用中断
IF位会禁止处理器INTR和LAPIC的中断
但是不会影响NMI的中断（包括NMI引脚以及APIC生成的NMI中断）也不会影响处理器自身产生的中断
在处理器reset的时候，他会清理掉包括IF在内的EFLAGS的所有内容

### 影响flag的指令
CLI，STI，PUSHF，POPF，IRET

### breakpoint
RF标志位，影响instruction breakpoint条件
当置位的时候，他阻止debug exception
当清理掉之后，debug exception才会产生
### 切换栈的时候阻止中断
一般来说切换栈需要设置SS，ESP，这是两条命令，肯定中间可能引起中断
（我看上去，这应该是32位的情况下）
所以处理器为了阻止这个问题，在mov或者pop修改SS的时候，会禁止中断
当然推荐的做法是使用LSS

### IDT 描述符
不做描述

### 中断处理
（按我的理解，这里涉及到的task gate等描述，应该是32位情况下的操作，在此不做详解）

### ERROR code
error code的模式为
bit 0 ext 置位表明来自一个interrupt或者一个更早的exception。
bit 1 idt 置位表明来自于一个gate描述符，否则表明来自于一个GDT或者LDT
bit 2 ti 只有当IDTflag没有置位的时候才可以，如果置位，表明来自于一个LDT，否则来自于一个GDT
segment表明来自于IDT，GDT，LDT的index
如果是一个空的error code
page-fault的error code则不一样
bit 0 P =0 表明错误来自于一个不存在的page，=1表明错误来自于一个页表的保护
bit 1 W/R =0 表明来自于一个read错误， =1 表明来自于一个write错误
bit 2 U/S =0 表明来自于一个内核态的错误 =1 表明来自于一个用户态的错误
bit 3 RSVD =0 表明错误不是来源于reserved bit violation， =1 表明保留位被设为了1
bit 4 I/D =0 表明不是来自于一个instruction fetch， =1 表明来自于一个instruction fetch
bit 5 PK =0 表明不是来自于一个protection keys，=1 表明来自于一个protection keys
bit 15 SGX =0 表明跟SGX无关，=1表明来自于violation of SGX-specific access-control requirements
其余均保留

error code的size取决于中断的默认size来确定到底是双字或者是单字，但是，64位下应该都是8bytes

另外需要注意一点（千万注意！！！），在iret指令下，不应该存在errorcode，所以需要软件手工弹出这个errorcode才能正常操作。
（所以我觉得很奇怪的是，我应该如何处理这一点？？？如果他来自于一个int n？）

### 64 bit和32位的差别
首先一部分就是上文的 volumn 1中的64位模式下的中断和异常的表述（非常不精确）
64位的IDT就不多描述了

#### 64bit的stack frame
首先说清楚了对齐这件事情，一定是8bytes对齐的
#### iret
也差不多
允许了SS段寄存器的NULL
同样的，作为栈切换机制的一部分，并不再从TSS中下载

#### 栈切换机制
IST（interrupt stack table）
简单来说，在IDT字段里面有一个IST字段，总共3bit，最多能够提供7个
如果ISTindex是0，那么仍然使用modified lagacy stack-switching mechanism

## TSS in IA-32e mode
实在一点的说
我原本也以为TSS并不重要的
不过64bit下的TSS被拿去做别的事情了
主要就是拿来做这个stack切换的事情。
具体布局非常简单，直接使用即可。
显然，不同特权级的栈切换是必须的，并且手册也建议在每个操作系统中至少包含一个
因此，我认为，这是需要实现的
按照上述的说法，IDT表里面生成table的时候就需要设定好IST的index
所以ist的值1-7应当被用于不同的stack，并且，tss的设定一定是在idt设定之前就做好的,所以需要先设置tss再搞idt
除此之外,ist指定的堆栈一定是per_cpu的。否则会出问题。

# aarch64
这个主要是在D1这里头

## D1.10 exception entry
当一个异常发生的时候
 - CPSR寄存器（当前状态寄存器，包括NZCVQ等标志位等等情况，都会保存到SPSR_ELx中，x是目标异常状态
 - 返回地址保存在ELR_ELx
 - DAIR都默认设为1，表示禁止嵌套中断
 - PSTATE的SSBS会保存SCTLR_ELx的DSSBS（虽然sctlr比较重要，但是ssbs这个位看上去只是个扩展，用于确认分支预测是否是安全的）
 - UAO扩展如果启用，那么PSTATE的UAO会设为0（好像也没啥用）
 - ESR_ELx表示了SError以及同步异常的原因
 - 其他若干跟扩展相关的内容
 - 会自动选择对应的SP_ELx寄存器指向的地址
 - 然后PC跳转到对应异常等级的异常向量表
 - 如果是一个abort，data abort，pc alignment fault 或者watchpoint会存储报错的地址到FAR_ELx
 - 另外，对于路由到EL2的情况，如果同样有instruction abort或者data abort（我的理解需要建立虚拟机的页面映射），还会保存早HPFAR_EL2

### 返回地址
对于异步异常，返回地址是中断发生的下一条指令或者没有执行的第一条指令
对于不是syscall的同步异常，返回的是触发同步异常的那条指令，而对于system call，返回的是svc指令的下一条指令

### 异常向量表
异常向量表这个东西，需要注意的是

 - 总共四组嘛，前两组表示异常等级没有变化，后两组表示从低等级的EL进入更高等级的异常（分低等级的是aarch64还是aarch32。
 - current EL with SP_0，如果配置了PSTATE的SP位，那么就可以使用SP_EL0作为这次异常处理的栈。


### ESR寄存器
bit 0:24 ISS
bit 25 IL，指明64还是32位的指令，不做兼容的话无需考虑这一位
bit 26:31 EC, 指明exception的原因（其中包括了svc在aarch64下的使用，相当于syscall了）

## D1.11 exception return
异常返回既包括返回到原先的执行流，也包括初始化的时候构造一个新的执行流。

PSTATE和PC都需要恢复到原先的值
PSTATE使用存储的SPSR，PC使用ELR

# 中断号的设计问题
在这里，我们需要设计中断号的安排情况。这是跟硬件平台具有充分的相关性的。

我还是描述一下我遇到的问题

在最初的设计中，我只实现了x86的情况。在这里，他有一个中断的表，描述了每个中断号对应的处理过程。我填充了他。并有一个统一的入口来解决中断的分发的问题。

但是当我试图实现aarch64的时候，事情变得不一样了。在aarch64中，对于中断向量表只有一个简单的16个表项的东西，但是在相应的过程中我们需要额外的根据其分类进行分发。

也就是说，如果是irq，包括什么sgi，ppi，spi，都会走irq的函数，而同步的那些错误（比如page fault，当然也分为数据的abort，指令的巴拉巴拉）以及syscall，也都被设计为sync方式的。除此之外，还需要区分同一个特权级的，和不同的特权级的。（甚至在不同特权级触发同一个的错误的处理方式也都不同，page fault内核可以触发，但是必须是被设计过的路径上触发并处理。但是比如运算指令的除零错误，内核如果出现，那直接挂吧）

在这个里面，我们期望的方式，是能够提供一个多架构下尽可能统一的入口，通过注册等方式，提供统一的所有方式的入口向量。

另一方面，我们希望RendezvOS本身被实现为一个混合内核的内核部分，内核态的其他组件应当而且必须使用syscall，svc指令来使用。（尽管在特权态调用相关指令，会有额外的开销）

因此，对于这部分的syscall设计又存在另一个要求，本质上，是去模仿arm的。

最终的设计如下：
我们并不改变原先的设计，同样映射到一个数组中

对于aarch64，只是在前64个项中，增加64个项用于处理不同的EC
而后面的irq则分别进行偏移64

对于riscv64，也采用一样的设计方法。

同时，我们需要改写原有的trap_frame的trap_id，这里需要重新设计，但是64位除去若干位用于表示中断号，其他的位数足够。
